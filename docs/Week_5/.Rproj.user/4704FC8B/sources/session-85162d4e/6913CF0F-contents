---
title: "Space time Occupacy model with INLA"
format: html
editor: source
editor_options: 
  chunk_output_type: console
bibliography: references.bib
execute: 
  echo: true
  warning: false
  message: false
  collapse: true
---

# Introduction 

In this document we show how to fit a space time occupacy  model for the dataset "hbefTrends" in the 'spOccupacy'  library.

```{r setup}
#| message: false
#| warning: false

library(INLA) 
library(tidyverse)
library(spOccupancy)
library(scico)
library(patchwork)
library(kableExtra)
library(raster)

rm(list = ls())

plot_inla_effects = function(effect)
{
  p1 = ggplot(data.frame(effect)) +
    geom_line(aes(ID, -mean)) + 
    geom_ribbon(aes(ID, ymin = -X0.025quant, ymax = -X0.975quant),
                alpha = 0.5)
  print(p1)
  
}


theme_maps = theme(axis.line=element_blank(),
                   axis.text.x=element_blank(),
                   axis.text.y=element_blank(),
                   axis.ticks=element_blank(),
                   axis.title.x=element_blank(),
                   axis.title.y=element_blank()
                   #legend.position="none",
                   #panel.background=element_blank(),
                   #panel.border=element_blank(),
                   #panel.grid.major=element_blank(),
                   #panel.grid.minor=element_blank(),
                   #plot.background=element_blank()
)
```

# Load and prepare the data
We first load the data and select the species of interest. Here we choose BTBW which is not one of the rare species present in the dataset.
 
Afterwards we prepare the data in the format that is required by the INLA library

```{r}

data(hbefTrends)

revi.data <- hbefTrends
sp.names <- dimnames(hbefTrends$y)[[1]]
revi.data$y <- revi.data$y[sp.names == 'REVI', , , ]
revi.data$coords = revi.data$coords/1000 #get this in km!

## data preparation for inla -----------------------------------------------
data = data.frame(revi.data$coords,
                  elev = revi.data$occ.covs$elev,
                  site = 1:373,
                  apply(revi.data$y,c(1,2), sum, na.rm = T)
) %>%
  pivot_longer(-c(X,Y,elev, site), names_to = "year", values_to = "counts") %>%
  mutate(time = as.numeric(as.factor(year)))

mday = data.frame(revi.data$coords,
                  apply(revi.data$det.covs$day,c(1,2), sum, na.rm = T)) %>%
  pivot_longer(-c(X,Y))
mtod = data.frame(revi.data$coords,
                  apply(revi.data$det.covs$tod,c(1,2), sum, na.rm = T)) %>%
  pivot_longer(-c(X,Y))
nsamples = data.frame(revi.data$coords, apply(revi.data$y,c(1,2), 
                                              function(x) sum(!is.na(x)))) %>%
  pivot_longer(-c(X,Y))

data = data %>%
  mutate(nvisits = nsamples$value,
         mday = mday$value,
         mtod = mtod$value) %>%
  dplyr::filter(nvisits >0)

data = data %>%  mutate(scale_mday = scale(mday),
                        scale_mtod = scale(mtod),
                        scale_time = scale(time),
                        scale_elev = scale(elev)) %>%
  mutate(scale_elev2 = scale_elev^2,
         scale_mday2 = scale_mday^2,
         int_detection = 1)



data %>% ggplot() + 
  geom_point(aes(X,Y, color= counts/nvisits), size = .5) + 
  facet_wrap(.~time) + theme_maps +
  scale_color_scico(na.value = "transparent") +
  ggtitle("Data")

```


```{r}
elev_raster= raster::rasterFromXYZ(data.frame(x = hbefElev$Easting/1000,
                                              y = hbefElev$Northing/1000,
                                              z = hbefElev$val))

elev_raster2 = resample(elev_raster, raster(nrows=100, ncols=100, 
                                            xmn=274, xmx=284,
                                            ymn=4866, ymx=4872, 
                                            vals=NULL))
values(elev_raster2) <- (values(elev_raster2) - mean(revi.data$occ.covs$elev)) / sd(revi.data$occ.covs$elev)


scale_time1 = (c(1:9) - mean(1:9))/sd(1:9)
pred_df = data.frame(x = rep(coordinates(elev_raster2)[,1],9),
                     y = rep(coordinates(elev_raster2)[,2],9),
                     scale_elev = rep(values(elev_raster2),9),
                     scale_time = rep(scale_time1, 
                                      each = length(values(elev_raster2))),
                     time = rep(c(1:9), each= length(values(elev_raster2)))) %>%
  dplyr::filter(!is.na(scale_elev))

xx = inla.group(c(data$scale_elev, pred_df$scale_elev),
                n = 35)


data$group_elev = xx[1:dim(data)[1]]
pred_df$group_elev = xx[-c(1:dim(data)[1])]

val_elev = sort(unique(xx))

```


# Model fit


## Model 1 


 This is  a separable space time model with linear predictos
$$
\eta_{st} = \beta_0 + f_1(\text{elev}) + f_2(t) + f_3(s)
$$
where
$f_1(\text{elev})$ is a smooth (RW2) effect of the elevation
$f_2(t)$ is a AR1 effect of time
$f_3(s)$ is an IID effect of location


```{r}
yy = c(1:9)
data1 = data %>% dplyr::filter(time %in% yy ) %>%
  mutate(random = seq_along(X))

formula1 = inla.mdata(cbind(counts,nvisits),int_detection) ~ 
  f(group_elev,model = "rw2", values = val_elev) + 
  f(site, model =  "iid") + 
  f(time, model = "iid")

time0 = system.time(model1 <- inla(formula1, 
                                   data=data1,  
                                   family= '0binomialS',   
                                   verbose = FALSE,
                                   control.compute = list( config = TRUE,
                                                           dic  = T,
                                                           waic = T),
                                   control.fixed = list(prec.intercept = 1/2.72,
                                                        prec = 1/2.72),
                                   control.family = list(control.link = list(model = "logit"), 
                                                         link.simple = "logit",
                                                         hyper = list(beta1 = list(param = c(0,1/2.72), 
                                                                                   initial = 0),
                                                                      beta2 = list(param = c(0,1/2.72)),
                                                                      beta3 = list(param = c(0,1/2.72)),
                                                                      beta4 = list(param = c(0,1/2.72)),
                                                                      beta5 = list(param = c(0,1/2.72))))))



```

## Model 2

```{r}
boundary = inla.nonconvex.hull(points = revi.data$coords, convex = .3)
mesh = inla.mesh.2d(boundary = boundary,
                    #   loc = cbind(data$X, data$Y),
                    max.edge = c(0.15,2),
                    min.angle = 20,
                    offset = c(.01, 1),
                    cutoff = 0.12,
)
ggplot() + inlabru::gg(mesh) +
  geom_point(data = data, aes(X,Y), pch = ".") +
  coord_equal() + theme_maps

spde <- inla.spde2.pcmatern(
  mesh = mesh, 
  prior.range = c(3, 0.5),
  prior.sigma = c(1, 0.5)) 

```


This is a space-time model with linear predictor as
$$
\eta_{st} = \beta_0 + f_1(\text{elev}) + f_2(t) + \omega(s) 
$$
with
$f_1()$ and $f_2()$ as before while $\omega(s)$ is a gaussian spatial 
field


```{r}
data1 = data %>% dplyr::filter(time %in% yy ) %>%
  mutate(random = seq_along(X))

iset_sp <- inla.spde.make.index(name = "spatialfield",
                                n.spde =  spde$n.spde)

A_sp <- inla.spde.make.A(mesh = mesh, 
                         loc = cbind(data1$X, data1$Y))

stk <- inla.stack(data=list(Ycounts = data1$counts, 
                            Ncounts = data1$nvisits,
                            scale_mday = data1$scale_mday,
                            scale_mday2 = data1$scale_mday2,
                            scale_mtod = data1$mtod,
                            Int_det = 1), #the response
                  A=list(A_sp,1),  #the A matrix; the 1 is included to make the list(covariates)
                  effects=list(c(list(Int_occ=1), #the Intercept
                                 iset_sp),  #the spatial index
                               #the covariates
                               list(scale_elev = data1$scale_elev, 
                                    scale_elev2 = data1$scale_elev2, 
                                    time = data1$time,
                                    group_elev = data1$group_elev,
                                    scale_time = data1$scale_time,
                                    site = data1$site,
                                    random = data1$random)), 
                  #this is a quick name so yo can call upon easily
                  tag='dat')

formula3_2 <- inla.mdata(cbind(Ycounts,Ncounts),
                         Int_det) ~ 
  f(group_elev, model = "rw2", values = val_elev) + 
  -1 + Int_occ +  
  f(time, model = "iid") + 
  f(spatialfield, model=spde) 

time2 = system.time(model3_2 <- inla(formula3_2, 
                                     data=inla.stack.data(stk),  
                                     family= '0binomialS',  
                                     control.fixed =  list(prec = 1, prec.intercept = 1),
                                     control.predictor=list(A=inla.stack.A(stk),
                                                            compute=TRUE), 
                                     control.compute = list(dic = TRUE, waic = TRUE, 
                                                            config = TRUE), 
                                     verbose = FALSE,
                                     control.family = list(control.link = list(model = "logit"), 
                                                           link.simple = "logit",
                                                           hyper = list(beta1 = list(param = c(0,1),
                                                                                     initial = -1),
                                                                        beta2 = list(param = c(0,1)),
                                                                        beta3 = list(param = c(0,1))
                                                           ))))
```


## Model 3
The last model is defined as:
$$
\eta_{st} = \beta_0 + f_1(\text{elev}) +  \omega(s,t) 
$$
with
$f_1()$ is as before while $\omega(s,t)$ is a space-time gaussian spatial 
field with AR1 time component


```{r}
data2 = data %>% dplyr::filter(time %in% yy) %>%
  mutate(random = seq_along(X))

iset_sp <- inla.spde.make.index(name = "spatialfield",
                                n.spde =  spde$n.spde,
                                n.group = length(yy))

A_sp <- inla.spde.make.A(mesh = mesh, 
                         loc = cbind(data2$X, data2$Y), 
                         group = data2$time)

stk <- inla.stack(data=list(Ycounts = data2$counts, 
                            Ncounts = data2$nvisits,
                            scale_mday = data2$scale_mday,
                            scale_mday2 = data2$scale_mday2,
                            scale_mtod = data2$mtod,
                            Int_det = 1), #the response
                  A=list(A_sp,1),  #the A matrix; the 1 is included to make the list(covariates)
                  effects=list(c(list(Int_occ=1), #the Intercept
                                 iset_sp),  #the spatial index
                               #the covariates
                               list(scale_elev = data2$scale_elev, 
                                    scale_elev2 = data2$scale_elev2, 
                                    time = data2$time,
                                    location = data2$site,
                                    group_elev = data2$group_elev,
                                    scale_time = data2$scale_time)), 
                  #this is a quick name so yo can call upon easily
                  tag='dat')

h.spec <- list(rho = list(prior = 'pc.cor0', param = c(0.5, 0.3)))


formula3_3 <- inla.mdata(cbind(Ycounts,Ncounts),
                         Int_det) ~ 
  -1   + Int_occ + 
  f(group_elev, model = "rw2", values = val_elev) + 
  f(spatialfield, 
    model=spde, 
    group = spatialfield.group, 
    control.group = list(model = 'iid'))

time3 = system.time(model3_3 <- inla(formula3_3, #the formula
                                     data=inla.stack.data(stk),  #the data stack
                                     family= '0binomialS',   #which family the data comes from
                                     control.fixed =  list(prec = 1, prec.intercept = 1),
                                     control.predictor=list(A=inla.stack.A(stk),
                                                            compute=TRUE),  #compute gives you the marginals of the linear predictor
                                     control.compute = list(dic = TRUE, waic = TRUE, 
                                                            config = TRUE), #model diagnostics and config = TRUE gives you the GMRF
                                     verbose = FALSE,
                                     control.inla = list(int.strategy = "eb"),
                                     control.family = list(control.link = list(model = "logit"), 
                                                           link.simple = "logit",
                                                           hyper = list(beta1 = list(param = c(0,1),
                                                                                     initial = 0),
                                                                        beta2 = list(param = c(0,1),
                                                                                     initial = 0),
                                                                        beta3 = list(param = c(0,1),
                                                                                     initial = 0),
                                                                        beta4 = list(param = c(0,1),
                                                                                     initial = 0)
                                                           ))))


```


# Results and Predictions
```{r}
# posterior samples -------------------------------------------------------

sample1 = inla.posterior.sample(1000, model1)
sample2 = inla.posterior.sample(1000, model3_2)
sample3 = inla.posterior.sample(1000, model3_3)

```


## Results 


### Running times
```{r}
table = data.frame(elapsed_Time = c(time0["elapsed"], time2["elapsed"], time3["elapsed"]),
                   DIC = c(model1$dic$dic, model3_2$dic$dic, model3_3$dic$dic),
                   WAIC = c(model1$waic$waic, model3_2$waic$waic, model3_3$waic$waic),
                   mlik = c(model1$mlik[1,1],model3_2$mlik[1,1],model3_3$mlik[1,1]))
rownames(table) = paste("Model", c(1:3))
kable(table)

```


### elevation effect 
First we look at the effect of elevation in the three fitted models

#+ plots
```{r}
data.frame(rbind(model1$summary.random$group_elev,
                 model3_2$summary.random$group_elev,
                 model3_3$summary.random$group_elev),
           model = paste("Model", rep(1:3,
                                      each = length(model1$summary.random$group_elev$mean)))) %>%
  ggplot() + geom_line(aes(ID, -mean, color = model, group  = model)) +
  geom_ribbon(aes(ID,ymin= -X0.025quant, ymax = -X0.975quant, 
                  group = model, fill = model), alpha = 0.3)

```



## Predictions over space

```{r}
yy = c(1,9)
pred1 = pred_df %>% dplyr::filter(time%in%yy)
A3_2 = inla.spde.make.A(mesh= mesh, loc = cbind(pred1$x, pred1$y))
A3_3 = inla.spde.make.A(mesh= mesh, loc = cbind(pred1$x, pred1$y),
                        group = pred1$time)

func1 = function(...)
{
  aa = -((Intercept) + 
           group_elev[as.numeric(as.factor(pred1$group_elev))] +
           time[pred1$time] 
  )
  rand = rnorm(length(pred1$group_elev), 0, 1/sqrt(theta[3]))
  aa + rand
}
func3_2 = function(...)
{
  aa = -(Int_occ + 
           group_elev[as.numeric(as.factor(pred1$group_elev))] +
           time[pred1$time] +
           (A3_2 %*% spatialfield)[,1] )
  aa
}
func3_3 = function(...)
{
  aa = -(Int_occ + 
           group_elev[as.numeric(as.factor(pred1$group_elev))] +
           (A3_3 %*% spatialfield)[,1] 
  )
  aa
}
fix1 = inla.posterior.sample.eval(func1, sample1)
fix3_2 = inla.posterior.sample.eval(func3_2, sample2)
fix3_3 = inla.posterior.sample.eval(func3_3, sample3)

pred2 = pred1 %>%
  mutate(sd1 = apply(fix1,1,sd),
         mean1 = apply(fix1,1,mean),
         sd2 = apply(fix3_2,1,sd),
         mean2 = apply(fix3_2,1,mean),
         sd3 = apply(fix3_3,1,sd),
         mean3 = apply(fix3_3,1,mean)) 


pred2 %>% dplyr::select(x,y,time, mean1, mean2, mean3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
  facet_grid(time~name) + scale_fill_scico() + theme_maps +
  ggtitle("Mean - logit scale")


pred2 %>% dplyr::select(x,y,time, sd1, sd2, sd3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
  facet_grid(time~name) + scale_fill_scico() + theme_maps+
  ggtitle("Sd - logit scale")


#' Probability of occurrence

probs1 = inla.link.logit(fix1, inverse = T)
quant1 = apply(probs1,1,quantile, c(0.025, 0.975))
probs2 = inla.link.logit(fix3_2, inverse = T)
quant2 = apply(probs2,1,quantile, c(0.025, 0.975))
probs3 = inla.link.logit(fix3_3, inverse = T)
quant3 = apply(probs3,1,quantile, c(0.025, 0.975))

pred2 = pred1 %>%
  mutate(mean1 = apply(probs1,1,mean),
         quant_range1 = quant1[2,]-quant1[1,],
         mean2 = apply(probs2,1,mean),
         quant_range2 = quant2[2,]-quant2[1,],
         mean3 = apply(probs3,1,mean),
         quant_range3 = quant3[2,]-quant3[1,]) 

pred2 %>% dplyr::select(x,y,time, mean1, mean2, mean3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
  facet_grid(time~name) + scale_fill_scico() + theme_maps+
  ggtitle("Mean Occurrence Probability")


pred2 %>% dplyr::select(x,y,time, quant_range1, quant_range2, quant_range3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
  facet_grid(time~name) + scale_fill_scico() + theme_maps+
  ggtitle("Difference in quantile (.975-.025)")
```

## Parameters for the detection part of the model

```{r}
# detecion paramters ------------------------------------------------------

npar = 1
tab1 = rbind(model1$summary.hyperpar[1:npar,c(1,3,5)],
             model3_2$summary.hyperpar[1:npar,c(1,3,5)],
             model3_3$summary.hyperpar[1:npar,c(1,3,5)])
rownames(tab1) = c (c("Int detection1"),
                    c("Int detection2"),
                    c("Int detection3"))

kable(tab1, booktabs = TRUE, digits = 2) %>% pack_rows(
  index = c("Model 1" = npar, "Model 2" = npar, "Model 3" = npar))


```



## predict detection

```{r}
func_det = function(...)
{
  theta[1] 
}

det1 = inla.posterior.sample.eval(func_det, sample1)
det2 = inla.posterior.sample.eval(func_det, sample2)
det3 = inla.posterior.sample.eval(func_det, sample3)

dd = data.frame(p1 = apply(inla.link.logit(det1, inverse = T),1,mean),
                p2 = apply(inla.link.logit(det2, inverse = T),1,mean),
                p3 = apply(inla.link.logit(det3, inverse = T),1,mean))
head(dd)            
```

    
