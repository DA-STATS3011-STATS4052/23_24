{
  "hash": "ea9349038d01b20a3459747efd261e38",
  "result": {
    "markdown": "---\ntitle: \"Week 8: Collaborative Coding 2\"\nengine: knitr\nformat:\n  pdf:\n    latex-auto-install: true\n  html:\n    code-link: true\n    code-fold: true\n    code-tools:\n      source: false\n      toggle: true\n    toc: true\n    toc-location: left\n    toc-title: Contents\n    number-sections: true\neditor: visual\neditor_options:\n  chunk_output_type: console\n---\n\n\n# Download a project\n\nThere are two main ways to download a project to your computer from GitHub and you should pick the one that makes sense for what you want to do:\n\n## Download a `.zip` package\n\nThe most straightforward method is to download a `.zip` file containing the latest version of the files.\n\n![](images/image22.png)\n\nClick on the green 'Code' button, then the 'Download ZIP' option. This will download a single file, archived and compressed using the common [ZIP](https://en.wikipedia.org/wiki/ZIP_(file_format)) file format. Double-clicking the file will extract its contents to a folder next to the original .zip file.\n\nAn important distinction here is that you are downloading just the codebase --- the files and folders of the repository --- and not the Git repository itself. This means you lose some of the key functionality of Git, for example, if the project maintainers make any updates to the project, you will need to manually re-download the `.zip` file and extract it again to see those changes, instead of being able to easily pull these changes (more on this in the next example!).\n\n## Clone\n\nAnother way to download a project to your computer is to use Git's `clone` method. To use `clone`, we need to tell Git installed on our computer to make a copy (or 'clone') of another repository, in this case from GitHub.\n\n::: panel-tabset\n\n## Command-line\n\nFirst, we need to copy the address of the repository we want to clone.\n\n![](images/image23.png)\n\n1. Click on the green button labelled \"Code\"\n\n2. Choose either HTTPS or SSH, depending on how you connect to GitHub with Git on your computer (see the Configuration section of Unit 1)\n\n3. Copy the address\n\nThen in your terminal, navigate to your desired folder and issue the following command:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit clone <address>\n```\n:::\n\n\nYou should now see the repository has been cloned to your computer.\n\n## GitHub Desktop\n\nFirst, navigate to the repository you want to clone on the GitHub website.\n\n![](images/image24.png)\n\n1. Click on the green button labelled 'Code'\n\n2. Click on 'Open with GitHub Desktop'\n\n3. You should then see a window like this pop up in GitHub Desktop:\n\n![](images/image25.png)\n\n1. The URL of the repository on GitHub has automatically been populated\n\n2. Choose where you would like the repository to be cloned to on your computer\n\n3. Click 'Clone'\n\n:::\n\nUsing this approach, we have a copy of the files and folders in the repository, but we have also copied the metadata which makes this into a Git repository. To answer the example above, now if a project maintainer makes an update to the project on GitHub, we can easily sync both versions:\n\n::: panel-tabset\n\n## Command-line\n\nIn the project folder just issue the `pull` command:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit pull\n```\n:::\n\n\n## GitHub Desktop\n\nOn GitHub Desktop, click the 'Fetch origin' button in the top bar:\n\n![](images/image26.png)\n\n:::\n\n# Branching and integrating\n\nIn this tutorial we are going to learn how to create a branch and make changes to it, then integrate this branch back into the main branch. This is particularly helpful when working collaboratively.\n\nIn Git, a branch represents a distinct version of the `main` repository, serving as a snapshot of your changes. When implementing new features or addressing issues, regardless of their scope, creating a new branch is the practice to isolate your modifications. This approach enhances code stability in the main branch and affords you the opportunity to refine your history before merging it into the primary codebase.\n\nWhen the work is complete, a branch can be merged with the main project.\nYou can even switch between branches and work on different projects without them interfering with each other.\n\nWe are also going to learn about Git's stash feature, and how it can help you when switching between branches.\n\n## Create a new local Git repository\n\nLet's create a new folder on our computer called 'tutorial3' and initialise Git:\n\n::: panel-tabset\n\n## Command-line\n\nCreate a directory for your 'tutorial3' work:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmkdir tutorial3\ncd tutorial3\n```\n:::\n\n\nand run git init inside:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit init\n```\n:::\n\n\n```\n\nInitialized empty Git repository in /Users/staff/Work/tutorial3/.git/\n\n```\n\n## GitHub Desktop\n\nChoose `File > New Repository...` from the menu.\n\nIn the \"Create a New Repository\" form, name the repository \"tutorial3\", set the \"Local Path\" field to your preferred location and click the \"Create Repository\" button:\n\n![](images/image27.png)\n\n:::\n\nAdd the following file to the repository:\n\n::: callout-note\n\n## example.md\n\nHello\n\n:::\n\nThen add and commit the file:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\ngit commit -m \"Add example.md\"\n```\n:::\n\n\n## GitHub Desktop\n\n![](images/image28.png)\n\n:::\n\nNext, let's create a branch named `shout` based on this commit.\n\n::: panel-tabset\n\n## Command-line\n\nWe can create a new branch and switch to it using the switch command with the -c flag:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch -c shout\n```\n:::\n\n\n```\n\nSwitched to a new branch 'shout'\n\n```\n\n## GitHub Desktop\n\n![](images/image29.png)\n\n:::\n\nAdd an exclamation mark to the end of the word within the `example.md` file:\n\n::: callout-note\n\n## example.md\n\nHello!\n\n:::\n\nThen commit the change:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\n```\n:::\n\n\n```\n\ngit commit -m \"Add exclamation mark\"\n\n[shout eed4222] Add exclamation mark\n\n1 file changed, 1 insertion(+), 1 deletion(-)\n\n```\n\n## GitHub Desktop\n\n![](images/image30.png)\n\n:::\n\nLet's take a quick look at the log:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --all --decorate --oneline --graph\n```\n:::\n\n\n```\n\n* eed4222 (HEAD -> shout) Add exclamation mark\n\n* 8f601cd (main) Add example.md\n\n```\n\n## GitHub Desktop\n\n![](images/image31.png)\n\n:::\n\nNow let's try merging the branch back into the `main` branch. First, switch back to `main`:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch main\n```\n:::\n\n\n```\n\nSwitched to branch 'main'\n\n````\n\n(Note, we don't include the -c flag as this branch already exists)\n\n## GitHub Desktop\n\n![](images/image32.png)\n\n:::\n\nThen merge our `shout` branch into `main`:\n\n::: panel-tabset\n\n## Command-line\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge shout\n```\n:::\n\n```\n\nUpdating 8f601cd..eed4222\n\nFast-forward\n\nexample.md | 2 +-\n\n1 file changed, 1 insertion(+), 1 deletion(-)\n\n```\n\n## GitHub Desktop\n\n![](images/image33.png)\n\n![](images/image34.png)\n\n:::\n\nWe can check that the version of our file in the main branch now has the exclamation mark:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat example.md\n```\n:::\n\n\n```\n\nHello!\n\n```\n\n## GitHub Desktop\n\n![](images/image35.png)\n\n:::\n\nAs the change is now reflected in our `main` branch, we can safely delete our `shout` branch:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit branch --delete shout\n```\n:::\n\n\n```\n\nDeleted branch shout (was eed4222).\n\n```\n\n## GitHub Desktop\n\nSimply right click on the `shout` branch here and select Delete\n\n![](images/image36.png)\n\n:::\n\n# Switching branches with the help of Git stash\n\nGiven the example above, branching with Git appears straightforward. However, this is not always the case. Sometimes Git won't let you switch branches. Let's create a scenario where we see an error when switching branches, try to understand why Git is stopping us, and look at a simple universal solution.\n\nCreate and switch to a new branch called `question`:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch -c question\n```\n:::\n\n\n```\n\nSwitched to a new branch 'question'\n\n```\n\n## GitHub Desktop\n\nFrom the main menu select Branch > New Branch and name the branch 'question':\n\n![](images/image37.png)\n\n:::\n\nLet's make a change to the file by changing the exclamation mark to a question mark:\n\n::: callout-note\n\n## example.md\n\nHello?\n\n:::\n\nAdd the change to the stage and commit:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\n```\n:::\n\n\n```\n\ngit commit -m \"Change exclamation mark to question mark\"\n\n[question 49806f4] Change exclamation mark to question mark\n\n1 file changed, 1 insertion(+), 1 deletion(-)\n\n```\n\n## GitHub Desktop\n\n![](images/image38.png)\n\n:::\n\nNow let's make another change to our file:\n\n::: callout-note\n\n## example.md\n\nHello?\n\nIs it me you're looking for?\n\n:::\n\nThis time, instead of committing, we will try to switch back to the main branch, and Git will tell us we can't switch branches currently as we would lose our local changes (see the next example for the error). Committing our latest change would let us then switch the branch, but what if we don't want to commit the change?\n\n::: panel-tabset\n\n## Command-line\n\nA common scenario is that you have started working on a problem, then when you check Git you realise you are working on the wrong branch, but now you have uncommitted changes and can't switch branches. For this scenario, there is the **stash**. Think of it as a clipboard with cut-and-paste functionality like you would have in a text editor, which will let us 'cut' our changes and store them somewhere safe, let us switch branches, and then paste them.\n\nLet's try it now:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch main\n```\n:::\n\n\n```\n\nerror: Your local changes to the following files would be overwritten by checkout:\n\nexample.md\n\nPlease commit your changes or stash them before you switch branches.\n\nAborting\n\n```\n\nGit complains that we will lose our local changes. Let's try out the stash:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit stash\n```\n:::\n\n\n```\n\nSaved working directory and index state WIP on question: 49806f4 Change exclamation mark to question mark\n\n```\n\nGit has used the abbreviation 'WIP' which stands for 'Work In Progress'.\n\nNow if we look at our file we'll see the 2nd line has disappeared:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat example.md\n```\n:::\n\n\n```\n\nHello?\n\n```\n\nWe can ask Git to show us our stash:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit stash show\n```\n:::\n\n\n```\n\nexample.md | 2 ++\n\n1 file changed, 2 insertions(+)\n\n```\n\nThis shows us which files have changed. We can add a `-p` (for 'patch') flag which will show us a diff:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit stash show -p\n```\n:::\n\n\n```\n\ndiff --git a/example.md b/example.md\n\nindex ebbc6cd..472b4c5 100644\n\n--- a/example.md\n\n+++ b/example.md\n\n@@ -1,2 +1,4 @@\n\nHello?\n\n+Is it me you're looking for?\n\n+\n```\n\nNow our local copy is 'clean' and we can safely switch branches:\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch main\n```\n:::\n\n\n```\nSwitched to branch 'main'\n```\n\nAnd we can apply our change to a different branch:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit stash apply\n```\n:::\n\n\n```\n\nAuto-merging example.md\n\nOn branch main\n\nChanges not staged for commit:\n\n(use \"git add <file>...\" to update what will be committed)\n\n(use \"git restore <file>...\" to discard changes in working directory)\n\nmodified:   example.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n```\n\nAnd now if we look at the file, we'll see our stashed change has been applied, but there is no question mark on \"Hello?\" as this change still resides on the `question` branch:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat example.md\n```\n:::\n\n\n```\n\nHello!\n\nIs it me you're looking for?\n\n```\n\nWe can now safely remove our stashed version:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit stash drop\n```\n:::\n\n\n```\n\nDropped refs/stash@{0} (00b8825ce0b6a0e3c2877f3c42c828fb4da4c922)\n\n```\n\nIt's important to `drop` the stash afterwards, or you'll end up with several items in the stash that could lead to applying the wrong one. Git has a shortcut for 'apply then drop' which is `git stash pop`.\n\n## GitHub Desktop\n\nLuckily for GitHub Desktop users, this stashing and stash-applying process is all handled by clicking a button.\n\nOnce we try to switch to the `main` branch:\n\n![](images/image39.png)\n\nGitHub Desktop offers us two options:\n\n* **Leave my changes on question** allows us to stash the changes and come back to the branch later and apply the stash\n\n* **Bring my changes to main** automates the process of stashing the changes, switching to the desired branch, and applying the stash.\n\nFor this tutorial, we will choose the latter option— 'Bring my changes to main':\n\n![](images/image40.png)\n\nAnd now if we look at the file, we'll see our stashed change has been applied, but no question mark as this change still resides on the `question` branch:\n\n![](images/image41.png)\n\n:::\n\n# Merging branches with the help of Git merge\n\nLet's stage and commit our 2nd line ``Is it me you're looking for?'' from then previous section:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\n```\n:::\n\n```\ngit commit -m \"Add 2nd line\"\n[main 6859b82] Add 2nd line\n1 file changed, 2 insertions(+)\n```\n\n## GitHub Desktop\n\n![](images/image42.png)\n\n:::\n\nLet's merge in the question mark.\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge question\n```\n:::\n\n\n```\n\nAuto-merging example.md\n\nMerge made by the 'ort' strategy.\n\nexample.md | 2 +-\n\n1 file changed, 1 insertion(+), 1 deletion(-)\n\n```\n\n## GitHub Desktop\n\n![](images/image44.png)\n\n:::\n\nLet's check the file:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat example.md\n```\n:::\n\n\n```\n\nHello?\n\nIs it me you're looking for?\n\n```\n\n## GitHub Desktop\n\n![](images/image45.png)\n\n:::\n\n# Merge conflicts\n\nIn the examples above we have introduced create a branch, making some changes and then integrating this back into main. However, what happens if you make a change to a line in a file on one branch, then you (or someone else) changes the same line of the same file on a different branch, what should Git do when you want to merge? This is a so-called **merge conflict**.\n\nIn this section, we're going to create a simple scenario where we will run into **merge conflicts** and explore two different ways to resolve them.\n\nWhen using `merge` to combine two branches, Git will first find a common \"base commit\" between the two branches, then compare the changes since this commit and attempt to compile a change list known as a \"merge commit\".\n\nGit tries to automate this process as much as possible, but if it finds two conflicting changes it won't try to guess which change should overrule the other. This usually happens when the same line in a file has been changed in both branches. In this case, while attempting to compile the merge commit, Git will go into a \"merge conflict\" state, which involves updating the conflicting files in the filesystem (or \"working tree\") with some special formatting to show you what it cannot guess, and Git will not allow you to commit the merge until you have manually decided what you want to happen.\n\nLet's create a branch named `capitalise` and switch to it:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch -c capitalise\n```\n:::\n\n\n```\nSwitched to a new branch 'capitalise'\n```\n\n## GitHub Desktop\n\n![](images/image46_1.png)\n\n:::\n\nNow we're going to make a different change to the file on the main branch. This time change the contents to the following:\n\n::: callout-note\n\n## example.md\n\nHELLO\n\n:::\n\nThen commit the change:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\ngit commit -m \"Capitalise example.md\"\n```\n:::\n\n\n```\n[capitalise 3da9dfb] Capitalise example.md\n\n1 file changed, 1 insertion(+), 3 deletions(-)\n\n```\n\n## GitHub Desktop\n\n![](images/image47.png)\n\n:::\n\nNow switch back to the `main` branch:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch main\n```\n:::\n\n\n```\n\nSwitched to branch 'main'\n\n```\n\n## GitHub Desktop\n\n![](images/image48.png)\n\n:::\n\nThe file should look like it did before the capitalisation, as that change is isolated on the `capitalise` branch:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat example.md\n```\n:::\n\n\n```\nHello?\n\nIs it me you're looking for?\n```\n\n## GitHub Desktop\n\n![](images/image49.png)\n\n:::\n\nNow we're going to make a different change to the file on the main branch. This time change the contents to the following:\n\n::: callout-note\n\n## example.md\n\nHello.\n\n:::\n\nStage and commit the change:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\ngit commit -m \"Add full stop to end of the line in example.md\"\n```\n:::\n\n\n```\n[main 7888fef] Add full stop to end of the line in example.md\n\n1 file changed, 1 insertion(+), 3 deletions(-)\n\n```\n\n## GitHub Desktop\n\n![](images/image50.png)\n\n:::\n\nLet's see what happens when we try to merge:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge capitalise\n```\n:::\n\n\n```\nAuto-merging example.md\n\nCONFLICT (content): Merge conflict in example.md\n\nAutomatic merge failed; fix conflicts and then commit the result.\n\n```\n\n## GitHub Desktop\n\n![](images/image51.png)\n\nLet's see what happens when we try to merge:\n\n![](images/image52.png)\n\nNext, GitHub Desktop will tell you which files need attention, and instruct you to open them in your preferred code editor.\n\n![](images/image53.png)\n\nThe Continue Merge button is disabled, as we need to resolve the conflicts in our files.\n\n:::\n\nLet's open up `example.md` in our preferred editor and see what is happening:\n\n```\n\n<<<<<<< HEAD\n\nHello.\n\n=======\n\nHELLO\n\n>>>>>>> capitalise\n\n```\n\nGit has modified our file to delineate a change that it cannot merge. The line (or lines) between `<<<<<<<` and `======` here show what you already had (you can tell because HEAD points to your current branch). The line (or lines) between `=======` and `>>>>>>>` is what was introduced by the other commit, in this case from the capitalise branch.\n\nIf this was a large file with multiple lines changed, Git will automatically merge the parts that it can, and will highlight the parts it can't like this, and we will have to go through each conflict and manually resolve them.\n\nLet's have a look at Git's status:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\ngit status -v\n\n```\n:::\n\n\n```\n\nOn branch main\n\nYou have unmerged paths.\n\n(fix conflicts and run \"git commit\")\n\n(use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n\n(use \"git add <file>...\" to mark resolution)\n\nboth modified:   example.md\n\n* Unmerged path example.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n```\n\n## GitHub Desktop\n\nNote that GitHub Desktop displays the conflict icon besides each file that needs attention:\n\n![](images/image54.png)\n\n:::\n\nGit's method for displaying merge conflicts by modifying the source files makes it very straightforward for us to resolve, by just manually editing the files as we want. However Git knows that there is now a danger that you could commit this merge conflict syntax, and when working with code, this will almost certainly cause a syntax error and break your project. So Git tries to protect us against this by going into a \"merge conflict\" state, where it wants you to either resolve or abort this action before you do anything else.\n\nLet's manually edit our file to what we want, like a mixture of both changes:\n\n::: callout-note\n## example.md\n\nHELLO.\n\n:::\n\n::: panel-tabset\n\n## Command-line\n\nAdd the file to the stage to mark it as resolved:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\n```\n:::\n\n\nWe can see Git is no longer in a merge conflict state:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status -v\n```\n:::\n\n\n```\n\nOn branch main\n\nAll conflicts fixed but you are still merging.\n\n(use \"git commit\" to conclude merge)\n\nChanges to be committed:\n\nmodified:   example.md\n\ndiff --git a/example.md b/example.md\n\nindex 8b94e8e..c886167 100644\n\n--- a/example.md\n\n+++ b/example.md\n\n@@ -1,2 +1,2 @@\n\n-Hello.\n\n+HELLO.\n\n```\n\n## GitHub Desktop\n\nOnce the special `<<<<<<<`, `======` and `>>>>>>>` syntax is removed from our files, GitHub Desktop detects that our merge conflict has been resolved and allows us to 'Continue Merge':\n\n![](images/image55.png)\n\n:::\n\nAnd we can conclude the merge.\n\n::: panel-tabset\n\n## Command-line\n\nI use the `--no-edit` flag to tell Git to use the default message for a merge commit:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\ngit commit --no-edit\n\n```\n:::\n\n\n```\n\n[main fe2d762] Merge branch 'capitalise'\n\n```\n\n## GitHub Desktop\n\n![](images/image56.png)\n\n:::\n\nWe have integrated our branch into the `main` branch and we can safely delete our short-lived branch `capitalise`:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit branch --delete capitalise\n```\n:::\n\n\n```\nDeleted branch capitalise (was 3da9dfb).\n```\n\n## GitHub Desktop\n\n![](images/image57.png)\n\n:::\n\n\n# Code Review: A better approach to resolving merge conflicts\n\nAlthough Git allows us to resolve a merge conflict as above, this is not considered the \"best practice\" way to achieve this result. We ended up with something different from both our branch contents and the main branch contents all in one merge conflict resolution, with no opportunity for oversight by someone else working on the project- i.e. we managed to skip the Code Review (aka. Pull Request) stage.\n\nA Pull Request on GitHub should be thought of as a preparation and checking stage for a Git `merge` (or `rebase`) operation. GitHub needs a 'base' branch to 'merge into', usually `main`, and a 'compare' branch to 'merge from'. If Git has indicated that a merge will result in a merge conflict, for the base branch as above, GitHub will not easily let you perform the merge process until this is fixed. So let's see how this could have been done differently.\n\nLet's create a new branch called `goodbye`:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch -c goodbye\n```\n:::\n\n```\nSwitched to a new branch 'goodbye'\n```\n\n## GitHub Desktop\nFrom the main menu select Branch > New Branch and name the branch 'goodbye':\n![](images/image58.png)\n\n:::\n\nLet's update the file like so:\n\n::: callout-note\n## example.md\nGOODBYE\n:::\n\nAnd commit the change:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\ngit commit -m \"Change hello to goodbye in example.md\"\n```\n:::\n\n```\n[goodbye 753e225] Change hello to goodbye in example.md\n1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n## GitHub Desktop\nFrom the main menu select Branch > New Branch and name the branch 'goodbye':\n![](images/image59.png)\n\n:::\n\nSwitch back to the main branch:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch main\n```\n:::\n\n```\nSwitched to branch 'main'\n```\n\n## GitHub Desktop\n![](images/image60.png)\n\n:::\n\nMake a change to the file on the main branch:\n\n::: callout-note\n## example.md\nHELLO\n:::\n\nAnd commit.\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit commit -m \"Remove full stop in example.md\"\n```\n:::\n\n```\n[main 27c4cc0] Remove full stop in example.md\n1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n## GitHub Desktop\n![](images/image61.png)\n\n:::\n\nThen try to merge:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge goodbye\n```\n:::\n\n```\nAuto-merging example.md\nCONFLICT (content): Merge conflict in example.md\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n## GitHub Desktop\n![](images/image62.png)\n![](images/image63.png)\n\n:::\n\nAnd again we have a merge conflict. This time, let's abort the merge:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge --abort\n```\n:::\n\n\n## GitHub Desktop\n![](images/image64.png)\n\n:::\n\nNow switch back to the `goodbye` branch:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch goodbye\n```\n:::\n\n```\nSwitched to branch 'goodbye'\n```\n\n## GitHub Desktop\n![](images/image65.png)\n\n:::\n\nAnd **merge `main` into our short-lived `goodbye` branch**:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge main\n```\n:::\n\n```\nAuto-merging example.md\nCONFLICT (content): Merge conflict in example.md\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n## GitHub Desktop\n![](images/image66.png)\n![](images/image67.png)\n\n:::\n\nNow if we head to our preferred code editor, we have almost the same merge conflict to resolve (except `HEAD` is now our `goodbye` branch):\n\n```\n<<<<<<< HEAD\nGOODBYE\n=======\nHELLO\n>>>>>>> main\n```\n\nAnd we can manually resolve it as before, this time with some Beatles lyrics:\n\n::: callout-note\n## example.md\nYou say GOODBYE and I say HELLO\n:::\n\n::: panel-tabset\n\n## Command-line\nAnd `add` to mark the conflict resolved:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add example.md\n```\n:::\n\nAnd commit the change.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit commit --no-edit\n```\n:::\n\n```\n[goodbye 34ca84f] Merge branch 'main' into goodbye\n```\n\n## GitHub Desktop\nGitHub Desktop has automatically detected that our merge conflict has been resolved:\n![](images/image68.png)\n\n:::\n\nAnd now our branch is ready for Code Review on GitHub via a Pull Request.\n\nWhen we switch back to the `main` branch:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit switch main\n```\n:::\n\n```\nSwitched to branch 'main'\n```\n\n## GitHub Desktop\n\n![](images/image69.png)\n\n:::\n\nOur change can be merged without a conflict. We will use `git squash` in the next steps.\nSquashing allows you to combine multiple commits in your branch's history into a single commit. This can help keep your repository's history more readable and understandable.\n\n\n::: panel-tabset\n\n## Command-line\n\"Fast-forward\" in Git terms means an automatic merge, or in other words, our merge will not result in a conflict.\n\nThe `goodbye` branch has 2 commits, which we can see by asking `git log` to compare it to the `main` branch:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline main..goodbye\n```\n:::\n\n```\n34ca84f Merge branch 'main' into goodbye\n753e225 Change hello to goodbye in example.md\n```\nSince we resolved the merge conflict with Beatles lyrics when merging the `main` branch into the `goodbye` branch, neither of these commit messages does a good job describing what we are about to integrate into `main`. So instead of transferring both commits to the `main` 'as is', let's 'squash' them into one:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit merge --squash goodbye\n```\n:::\n\n```\nUpdating 27c4cc0..34ca84f\nFast-forward\nSquash commit -- not updating HEAD\nexample.md | 2 +-\n1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\nThen commit the squashed change with a more descriptive message:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit commit -m 'Change to Beatles lyrics'\n```\n:::\n\n```\n[main 08a1ff2] Change to Beatles lyrics\n1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n## GitHub Desktop\n![](images/image70.png)\n![](images/image71.png)\n\n\nThis time instead of clicking 'Create a merge commit', click the little arrow on the right of the button and select 'Squash and merge':\n\n![](images/image72.png)\n\nNow if we look at the history tab we can see a commit with the message 'Squashed commit of the following:'. If you click on 'Expand' on the right, we can see the description of the commit has a log of the commits that were squashed into this one:\n\n![](images/image73.png)\n\nLet's change the title to something more descriptive by right-clicking on the commit message and selecting 'Amend commit...':\n\n![](images/image74.png)\n\nThen change the message to 'Change to Beatles lyrics' and click 'Amend last commit':\n\n![](images/image75.png)\n\n:::\n\n\n\"Fast-forward\" in Git terms means an automatic merge, or in other words, our merge will not result in a conflict.\n\nFinally, you can safely delete the goodbye branch:\n\n::: panel-tabset\n\n## Command-line\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit branch --delete goodbye\n```\n:::\n\n```\nerror: The branch 'goodbye' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D goodbye'.\n```\n\n## GitHub Desktop\n![](images/image76.png)\n\n:::\n\nSo to recap, we have prepared our branch for integration by first combining any new changes from the `main` branch into our branch and resolving the merge conflicts in isolation, creating a \"final version\" of the change we want to make with our branch ready to be checked, before attempting to integrate our branch back into the `main` branch.\n\nIf you need to keep your short-lived branch open for some reason, it's advised to merge any recent changes from `main` into your branch often, to avoid painful merge conflicts later.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}